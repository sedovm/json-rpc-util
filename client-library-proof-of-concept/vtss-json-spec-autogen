#!/usr/bin/env ruby

require 'pp'
require 'json'
require 'optparse'

ignore_description = false
call_opts = OptionParser.new do |opts|
    opts.banner = """Usage: vtss-json-spec-autogen [Options] <json-spec>"""
    opts.separator ""
    #opts.separator "Compare two vtss-json-spec, and print the changes"
    opts.separator ""
    opts.separator "Options:"

    opts.on("-h", "--help", "Show this message") do
        puts opts
        exit
    end
    #opts.on("-d", "--ignore-description", "Suppress changes in description fields") do
    #    ignore_description = true
    #end
end

# todo, make option
hdr = File.open("./vtss-client.hxx", 'w')
impl = File.open("./vtss-client.cxx", 'w')

call_opts.parse!
if ARGV.size != 1
    puts call_opts
    exit
end

TYPE_REMAP = {
    "char *"                   => "std::string",
    "unsigned char *"          => "std::vector<unsigned char>",
    "vtss_bool_t"              => "bool",
    "vtss_appl_password_t"     => "std::string",
    "vtss_ifindex_t"           => "std::string",
    "vtss_inet_address_t"      => "std::string",
    "mesa_ip_addr_t"           => "std::string",
    "mesa_ipv4_network_t"      => "std::string",
    "mesa_ipv4_t"              => "std::string",
    "mesa_ipv6_network_t"      => "std::string",
    "mesa_ipv6_t"              => "std::string",
    "vtss_appl_vcl_proto_t"    => "std::string",
    "string"                   => "std::string",

}

impl.puts <<PREMATTER
// Autogenerated header do not edit ////////////////////////////////////////////
#include "vtss-client.hxx"

// Global variable - non thread safe hack...
std::string uri_json_rpc;

void parse(const Json::Value&, vtss_appl_json_rpc_inventory_t&) {
    throw std::runtime_error("not implemented");
}

template<typename T>
void parse(const Json::Value &v, T *x);

template<typename K, typename V>
void parse(const Json::Value &v, std::map<K, V> &m);

template<typename K>
void parse(const Json::Value &v, std::set<K> &s);

template<typename... T>
void parse(const Json::Value &v, std::tuple<T...> x);

template<typename T>
void parse(const Json::Value &v, T *x) { parse(v, *x); }

template<typename K, typename V>
void parse(const Json::Value &j, std::map<K, V> &m) {
    for (const auto &e : j) {
        std::pair<K, V> p;
        parse(e["key"], p.first);
        parse(e["val"], p.second);
        m.insert(p);
    }
}

template<typename K>
void parse(const Json::Value &v, std::set<K> &s) {
    throw std::runtime_error("not implemented");
}

template<typename... T>
void parse(const Json::Value &v, std::tuple<T...> x) {
    throw std::runtime_error("not implemented");
}

PREMATTER

hdr.puts <<PREMATTER
// Autogenerated header do not edit ////////////////////////////////////////////
#include <map>
#include <set>
#include <tuple>
#include <string>
#include <vector>
#include <iostream>
#include <stdint.h>

#include "json/reader.h"
#include "json/writer.h"
#include "restclient-cpp/restclient.h"

// Global variable - non thread safe hack...
extern std::string uri_json_rpc;

// Predefined types ////////////////////////////////////////////////////////////
struct vtss_appl_evc_mpls_tp_pw_conf_t {};  // todo
struct vtss_appl_json_rpc_inventory_t {};  // todo

struct mesa_mac_t {
    unsigned char addr[6];
};

inline bool operator<(const mesa_mac_t &a, const mesa_mac_t &b) {
    if (a.addr[0] != b.addr[0]) return a.addr[0] < b.addr[0];
    if (a.addr[1] != b.addr[1]) return a.addr[1] < b.addr[1];
    if (a.addr[2] != b.addr[2]) return a.addr[2] < b.addr[2];
    if (a.addr[3] != b.addr[3]) return a.addr[3] < b.addr[3];
    if (a.addr[4] != b.addr[4]) return a.addr[4] < b.addr[4];
    if (a.addr[5] != b.addr[5]) return a.addr[5] < b.addr[5];
    return false;
}

typedef int vtss_rc;
typedef std::string vtss_ifindex_t;
typedef std::vector<vtss_ifindex_t>  vtss_port_list_stackable_t;
typedef std::vector<uint32_t> vtss_snmp_oid_t;
typedef uint16_t mesa_vid_t;
typedef std::vector<mesa_vid_t>  vtss_vid_list_t;
typedef std::string binary_buffer;
typedef int int32e_9_t;

Json::Value serialize(const mesa_mac_t &x);
Json::Value serialize(const std::vector<uint16_t> &x);
Json::Value serialize(const std::vector<uint32_t> &x);
Json::Value serialize(const std::vector<std::string> &x);
Json::Value serialize(const std::vector<unsigned char> &x);
Json::Value serialize(vtss_appl_evc_mpls_tp_pw_conf_t x);
Json::Value serialize(std::string x);
Json::Value serialize(int8_t x);
Json::Value serialize(int16_t x);
Json::Value serialize(int32_t x);
Json::Value serialize(int64_t x);
Json::Value serialize(uint8_t x);
Json::Value serialize(uint16_t x);
Json::Value serialize(uint32_t x);
Json::Value serialize(uint64_t x);
Json::Value serialize(time_t x);
Json::Value serialize(binary_buffer x);

// General purpose RPC caller //////////////////////////////////////////////////
template <typename... Args>
Json::Value vtss_json_rpc_call_(const std::string &method, Json::Value &v,
                            const Args &... args);

template <typename Head, typename... Tail>
Json::Value vtss_json_rpc_call_(const std::string &method, Json::Value &v,
                            const Head &head, const Tail &... tail) {
    v["params"].append(serialize(head));
    return vtss_json_rpc_call_(method, v, tail...);
}

template <>
inline Json::Value vtss_json_rpc_call_<>(const std::string &method, Json::Value &v) {
    auto res = RestClient::post(uri_json_rpc, "text/json",
                                v.toStyledString());

    if ((res.code < 200 || res.code > 299) &&
        (res.code < 500 || res.code > 599)) {
        throw std::runtime_error("Network error");
    }

    Json::Reader reader;
    Json::Value root;


    if (!reader.parse(res.body, root, false))
        throw std::runtime_error("Failed to parse!");

    //std::cout << root << std::endl;

    if (!root.isObject()) throw std::runtime_error("Not a object");
    if (!root.isMember("error")) throw std::runtime_error("No error member");
    if (!root.isMember("result")) throw std::runtime_error("No result member");

    return root;
}

template <typename... Args>
Json::Value vtss_json_rpc_call(const std::string &method, const Args &... args) {
    RestClient::setAuth("admin", "");

    Json::Value msg(Json::objectValue);
    msg["method"] = method;
    msg["id"] = "jsonrpc";
    msg["params"] = Json::Value(Json::arrayValue);

    return vtss_json_rpc_call_(method, msg, args...);
}

// Implementation of base types ////////////////////////////////////////////////
inline Json::Value serialize(bool x) { return Json::Value(x); }
inline Json::Value serialize(const char *x) { return Json::Value(x); }

inline Json::Value serialize(const mesa_mac_t &x) {
    throw std::runtime_error("not implemented");
    return Json::Value("00:00:00:00:00:00"); // TODO
}

inline Json::Value serialize(const std::vector<uint16_t> &x) {
    Json::Value a(Json::arrayValue);
    for (auto i : x) a.append(i);
    return a;
}

inline Json::Value serialize(const std::vector<uint32_t> &x) {
    Json::Value a(Json::arrayValue);
    for (auto i : x) a.append(i);
    return a;
}

inline Json::Value serialize(const std::vector<std::string> &x) {
    Json::Value a(Json::arrayValue);
    for (auto i : x) a.append(i);
    return a;
}

inline Json::Value serialize(const std::vector<unsigned char> &x) {
    Json::Value a(Json::arrayValue);
    for (auto i : x) a.append(i);
    return a;
}

inline Json::Value serialize(vtss_appl_evc_mpls_tp_pw_conf_t x) {
    throw std::runtime_error("not implemented");
    return Json::Value(""); // TODO
}

inline Json::Value serialize(std::string x) { return Json::Value(x); }
inline Json::Value serialize(int8_t x) { return Json::Value(x); }
inline Json::Value serialize(int16_t x) { return Json::Value(x); }
inline Json::Value serialize(int32_t x) { return Json::Value(x); }
inline Json::Value serialize(int64_t x) { return Json::Value((Json::Value::Int64)x); }
inline Json::Value serialize(uint8_t x) { return Json::Value(x); }
inline Json::Value serialize(uint16_t x) { return Json::Value(x); }
inline Json::Value serialize(uint32_t x) { return Json::Value(x); }
inline Json::Value serialize(uint64_t x) { return Json::Value((Json::Value::UInt64)x); }


inline void parse(const Json::Value &v, mesa_mac_t &x) {
    throw std::runtime_error("not implemented");
}

inline void parse(const Json::Value &v, std::vector<uint16_t> &x) {
    if (!v.isArray()) throw std::runtime_error("Unexpected type");
    for (auto i : v) {
        if (!i.isUInt()) throw std::runtime_error("Unexpected type");
        x.push_back(i.asUInt());
    }
}

inline void parse(const Json::Value &v, std::vector<uint32_t> &x) {
    if (!v.isArray()) throw std::runtime_error("Unexpected type");
    for (auto i : v) {
        if (!i.isUInt()) throw std::runtime_error("Unexpected type");
        x.push_back(i.asUInt());
    }
}

inline void parse(const Json::Value &v, std::vector<std::string> &x) {
    if (!v.isArray()) throw std::runtime_error("Unexpected type");
    for (auto i : v) {
        if (!i.isString()) throw std::runtime_error("Unexpected type");
        x.push_back(i.asString());
    }
}

inline void parse(const Json::Value &v, std::vector<unsigned char> &x) {
    if (!v.isArray()) throw std::runtime_error("Unexpected type");
    for (auto i : v) {
        if (!i.isUInt()) throw std::runtime_error("Unexpected type");
        x.push_back(i.asUInt());
    }
}

inline void parse(const Json::Value &v, vtss_appl_evc_mpls_tp_pw_conf_t x) {
    throw std::runtime_error("not implemented");
}

inline void parse(const Json::Value &v, bool &x) {
    if (!v.isBool()) throw std::runtime_error("Unexpected type");
    x = v.asBool();
}

inline void parse(const Json::Value &v, std::string &x) {
    if (!v.isString()) throw std::runtime_error("Unexpected type");
    x = v.asString();
}

inline void parse(const Json::Value &v, int8_t &x) {
    if (!v.isInt()) throw std::runtime_error("Unexpected type");
    x = v.asInt();
}

inline void parse(const Json::Value &v, int16_t &x) {
    if (!v.isInt()) throw std::runtime_error("Unexpected type");
    x = v.asInt();
}

inline void parse(const Json::Value &v, int32_t &x) {
    if (!v.isInt()) throw std::runtime_error("Unexpected type");
    x = v.asInt();
}

inline void parse(const Json::Value &v, int64_t &x) {
    if (!v.isInt()) throw std::runtime_error("Unexpected type");
    x = v.asInt();
}

inline void parse(const Json::Value &v, uint8_t &x) {
    if (!v.isUInt()) throw std::runtime_error("Unexpected type");
    x = v.asUInt();
}

inline void parse(const Json::Value &v, uint16_t &x) {
    if (!v.isUInt()) throw std::runtime_error("Unexpected type");
    x = v.asUInt();
}

inline void parse(const Json::Value &v, uint32_t &x) {
    if (!v.isUInt()) throw std::runtime_error("Unexpected type");
    x = v.asUInt();
}

inline void parse(const Json::Value &v, uint64_t &x) {
    if (!v.isUInt()) throw std::runtime_error("Unexpected type");
    x = v.asUInt();
}

inline bool operator< (const vtss_appl_evc_mpls_tp_pw_conf_t &a, const vtss_appl_evc_mpls_tp_pw_conf_t &b) {
    throw std::runtime_error("not implemented");
    return false;
}

PREMATTER


TYPE_PASS_BY_VALUE = [
    "vtss_ifindex_t",
    "int8_t",
    "int16_t",
    "int32_t",
    "int64_t",
    "uint8_t",
    "uint16_t",
    "uint32_t",
    "uint64_t",
    "time_t"
]

def cxx_member_name m
    if m =~ /^\d/
        return "_#{m}"
    end

    m = m.gsub(/-/, "_")
    return m
end

def cxx_method_name m
    return "vtss_#{m["method-name"].gsub(/[-\.]/, "_")}"
end

def cxx_enum_name type
    type = type.gsub(/-/, "_")
    return type
end

def cxx_enum_element_name type, element
    e = type.sub(/_t$/, "")
    e += "_#{element}"
    e.upcase!
    e = e.gsub(/-/, "_")
    return e
end

def cxx_is_get_all e
    #{
    #  "method-name": "port.status.get",
    #  "description": "This is an overload of port.status.get without any input parameters. It is used to implement a get-all functionallity.",
    #  "group-name": "port.status",
    #  "notification": "port.status.update",
    #  "params": [ ],
    #  "result": [
    #    {
    #      "name": "res",
    #      "type": {
    #        "class": "Array",
    #        "encoding-type": "Array",
    #        "type": {
    #          "class": "Struct",
    #          "encoding-type": "Object",
    #          "elements": [
    #            {
    #              "name": "key",
    #              "semantic-name": "ifindex",
    #              "type": "vtss_ifindex_t"
    #            },
    #            {
    #              "name": "val",
    #              "semantic-name": "status",
    #              "type": "vtss_appl_port_mib_status_t"
    #            }
    #          ]
    #        }
    #      }
    #    }
    #  ]
    #},
    if e["result"].size != 1
        return false;
    end

    if e["result"][0]["type"].class == String
        return false;
    end

    if e["result"][0]["type"]["class"] != "Array"
        return false;
    end

    if e["result"][0]["type"]["type"]["class"] != "Struct"
        return false;
    end

    if e["result"][0]["type"]["type"]["elements"].size != 2
        return false;
    end

    if e["result"][0]["type"]["type"]["elements"][0]["name"] != "key"
        return false;
    end

    if e["result"][0]["type"]["type"]["elements"][1]["name"] != "val"
        return false;
    end

    return true
end

def cxx_type_name e
    if e["type"].class == String
        if TYPE_REMAP[e["type"]].nil?
            return e["type"]

        else
            return TYPE_REMAP[e["type"]]

        end
    end

    t = e["type"]
    case t["class"]
    when "Array"
        array_type = t["type"]
        if array_type.class == String
            return "std::vector<array_type>";
        end

        case array_type["class"]
        when "Struct"
            if array_type["elements"].size == 2 and array_type["elements"][0]["name"] == "key" and array_type["elements"][1]["name"] == "val"
                if array_type["elements"][0]["type"].class == NilClass
                    #return "std::vector<#{array_type["elements"][1]["type"]}>"
                    return "std::vector<#{cxx_type_name(array_type["elements"][1])}>"

                elsif array_type["elements"][1]["type"].class == NilClass
                    return "std::set<#{cxx_type_name(array_type["elements"][0])}>"

                else
                    return "std::map<#{cxx_type_name(array_type["elements"][0])}, #{cxx_type_name(array_type["elements"][1])}>"

                end
            else
                raise "Unhandled nested structure #{array_type}"
            end
        else
            raise "Unhandled class #{array_type["class"]}"
        end

    when "Tuple"
        first = true;
        s = "std::tuple<"

        t["elements"].each do |tt|
            if first
                first = false
            else
                s += ", "
            end

            s += cxx_type_name(tt)
        end

        s += ">"
        return s
    else
        raise "Unhandled class #{t["class"]}"
    end
end

def cxx_type_name_as_input e
    if TYPE_PASS_BY_VALUE.include? cxx_type_name(e)
        return "const #{cxx_type_name(e)} "
    else
        return "const #{cxx_type_name(e)} &"
    end
end

def cxx_type_name_as_output e
    return "#{cxx_type_name(e)} *"
end

def cxx_method_prototype(m)
    cnt = 0
    s = "vtss_rc #{cxx_method_name(m)}("
    m["params"].each do |p|
        s += "," if cnt > 0
        s += "\n        "
        cnt += 1
        s += "#{cxx_type_name_as_input p}"
        if p["name"]
            s += "#{cxx_member_name(p["name"])}"
        else
            s += "argument#{cnt}"
        end
    end

    m["result"].each do |r|
        s += "," if cnt > 0
        s += "\n        "
        cnt += 1
        s += "#{cxx_type_name_as_output r}"
        if r["name"]
            s += "#{cxx_member_name(r["name"])}"
        else
            s += "argument#{cnt}"
        end
    end

    s += ")";
end

spec = JSON.parse(File.read(File.expand_path(ARGV[0])))

hdr.puts <<PREMATTER
// Type declarations ///////////////////////////////////////////////////////////
PREMATTER
spec["types"].each do |t|
    # We prefere to pass enums by value
    TYPE_PASS_BY_VALUE << t["type-name"] if t["class"] == "Enum"

    case t["class"]
    when "Enum"
        TYPE_PASS_BY_VALUE << t["type-name"]

        b = t["type-name"]
        t["description"].split("\n").each{|x| hdr.puts "// #{x}" }
        hdr.puts "enum #{cxx_enum_name(b)} {"
        t["elements"].each do |e|
            if e["description"]
                e["description"].split("\n").each{|x| hdr.puts "    // #{x}" }
            end
            hdr.puts "    #{cxx_enum_element_name(b, e["name"])} = #{e["value"]},"
        end

        hdr.puts "};"
        hdr.puts ""
        hdr.puts "Json::Value serialize(#{cxx_enum_name(b)} x);"
        hdr.puts "void parse(const Json::Value &v, #{cxx_enum_name(b)} &x);"
        hdr.puts ""

        impl.puts "Json::Value serialize(#{cxx_enum_name(b)} x) {"
        impl.puts "    Json::Value v(Json::objectValue);"
        impl.puts ""
        impl.puts "    switch (x) {"
        t["elements"].each do |e|
            impl.puts "        case #{cxx_enum_element_name(b, e["name"])}: return Json::Value(\"#{e["name"]}\");"
        end
        impl.puts "    };"
        impl.puts ""
        impl.puts "    throw std::runtime_error(\"out-of-range-enum\");"
        impl.puts "}"
        impl.puts ""

        impl.puts "void parse(const Json::Value &v, #{cxx_enum_name(b)} &x) {"
        impl.puts "    if (!v.isString()) throw std::runtime_error(\"Unexpected type\");"
        impl.puts ""
        t["elements"].each do |e|
            impl.puts "    if (v.asString() == std::string(\"#{e["name"]}\")) {"
            impl.puts "        x = #{cxx_enum_element_name(b, e["name"])};"
            impl.puts "        return;"
            impl.puts "    }"
        end
        impl.puts ""
        impl.puts "    throw std::runtime_error(\"out-of-range-enum\");"
        impl.puts "}"
        impl.puts ""

    when "Struct"
        t["description"].split("\n").each{|x| hdr.puts "// #{x}" }
        hdr.puts "struct #{t["type-name"]} {"

        cnt = 0
        t["elements"].each do |e|
            if cnt > 0
                hdr.puts ""
            end
            cnt += 1
            if e["description"]
                e["description"].split("\n").each{|x| hdr.puts "    // #{x}" }
            end
            hdr.puts "    #{cxx_type_name(e)} #{cxx_member_name(e["name"])};"
        end

        hdr.puts "};"
        hdr.puts ""
        hdr.puts "bool operator< (const #{t["type-name"]} &a, const #{t["type-name"]} &b);"
        hdr.puts "Json::Value serialize(const #{t["type-name"]} &x);"
        hdr.puts "void parse(const Json::Value &v, #{t["type-name"]} &x);"
        hdr.puts ""

        impl.puts "Json::Value serialize(const #{t["type-name"]} &x) {"
        impl.puts "    Json::Value v(Json::objectValue);"
        impl.puts ""
        t["elements"].each do |e|
            impl.puts "    v[\"#{e["name"]}\"] = serialize(x.#{cxx_member_name(e["name"])});"
        end
        impl.puts ""
        impl.puts "    return v;"
        impl.puts "}"
        impl.puts ""
        impl.puts "void parse(const Json::Value &v, #{t["type-name"]} &x) {"
        t["elements"].each do |e|
            impl.puts "    parse(v[\"#{e["name"]}\"], x.#{cxx_member_name(e["name"])});"
        end
        impl.puts "}"
        impl.puts ""
        impl.puts "bool operator< (const #{t["type-name"]} &a, const #{t["type-name"]} &b) {"
        t["elements"].each do |e|
            a = "a.#{cxx_member_name(e["name"])}"
            b = "b.#{cxx_member_name(e["name"])}"
            impl.puts "    if ((!(#{a} < #{b})) && (!(#{b} < #{a}))) return #{a} < #{b};"
        end
        impl.puts "    return false;"
        impl.puts "}"
        impl.puts ""

    when "TypeSpecification"

    else

    end

end


hdr.puts <<PREMATTER
// Method prototypes ///////////////////////////////////////////////////////////
PREMATTER

spec["methods"].each do |m|
    if m["description"]
        m["description"].split("\n").each{|x| hdr.puts "// #{x}" }
    end

    hdr.print "#{cxx_method_prototype(m)};\n\n"
end

spec["methods"].each do |m|
    cnt = 0

    impl.puts "#{cxx_method_prototype(m)} {"
    impl.print "    Json::Value v = vtss_json_rpc_call(\"#{m["method-name"]}\""

    m["params"].each do |p|
        cnt += 1
        impl.print ", "
        if p["name"]
            impl.print "#{cxx_member_name(p["name"])}"
        else
            impl.print "argument#{cnt}"
        end
    end

    impl.print ");\n\n"

    impl.puts "    if (!v[\"error\"].isNull()) {"
    impl.puts "        if (!v[\"error\"].isObject()) return -1;"
    impl.puts "        if (!v[\"error\"].isMember(\"code\")) return -1;"
    impl.puts "        if (!v[\"error\"][\"code\"].isInt()) return -1;"
    impl.puts "        return v[\"error\"][\"code\"].asInt();"
    impl.puts "    }"
    impl.puts ""


    if cxx_is_get_all(m)
        impl.puts "    if (!v[\"result\"].isArray()) throw std::runtime_error(\"Result is not an array\");"
        cnt += 1
        if m["result"][0]["name"]
            impl.puts "    parse(v[\"result\"], #{cxx_member_name(m["result"][0]["name"])});"
        else
            impl.puts "    parse(v[\"result\"], argument#{cnt});"
        end
    else
        if m["result"].size == 0
        elsif m["result"].size == 1
            if m["result"][0]["name"]
                impl.puts "    parse(v[\"result\"], #{cxx_member_name(m["result"][0]["name"])});"
            else
                impl.puts "    parse(v[\"result\"], argument#{cnt});"
            end
        else
            impl.puts "    if (!v[\"result\"].isArray()) throw std::runtime_error(\"Result is not an array\");"
            impl.puts "    if (v[\"result\"].size() != #{m["result"].size}) throw std::runtime_error(\"Unexpected result count\");"
            impl.puts ""

            i = 0;
            m["result"].each do |r|
                cnt += 1
                if r["name"]
                    impl.puts "    parse(v[\"result\"][#{i}], #{cxx_member_name(r["name"])});"
                else
                    impl.puts "    parse(v[\"result\"][#{i}], argument#{cnt});"
                end

                i += 1
            end
        end
    end

    impl.puts ""
    impl.puts "    return 0;"
    impl.puts "}"
    impl.puts ""
end

